# 游戏系统优化实施方案（最终版）

## 一、场景架构优化（解决重复场景问题）

### 问题分析

* 当前有199个场景（branches），每个选择都创建新场景

* 导致大量重复内容和维护困难

### 解决方案

1. **引入场景内分支机制**

   * 在同一个场景内处理多个选择，避免重复创建场景

   * 支持条件判断显示不同选项

   * 减少场景数量，提高维护效率

2. **添加步骤系统**

   * 在一个场景内定义多个步骤（steps）

   * 每个步骤可以有不同的描述和选择

   * 完成当前步骤后进入下一步骤

3. **支持循环场景**

   * 允许场景重复使用，避免重复定义

   * 通过参数传递实现场景差异化

### 数据结构扩展

```typescript
interface Scene {
  branch_id: string;
  chapter: string;
  scene_detail: string;
  steps?: Step[];  // 新增：步骤系统
  choices: Choice[];
  conditions?: Condition[];  // 新增：条件分支
}

interface Step {
  step_id: string;
  title: string;
  description: string;
  choices: Choice[];
}
```

***

## 二、数值累加系统（核心需求）

### 问题分析

* 当前 `status_update` 只是显示文本，没有实际更新数值

* 缺乏灵活的数值累加机制

### 解决方案

1. **扩展数值类型**

   * 支持整数类型（金币、经验值、生命值）

   * 支持浮点数类型（精确数值）

   * 支持百分比类型（暴露度、羞耻感等）

2. **数值运算系统**

   * 加法：`+1`、`+5`、`+10`

   * 减法：`-1`、`-5`、`-10`

   * 乘法：`*2`、`*1.5`

   * 除法：`/2`、`/1.5`

   * 设置值：`=100`

3. **数值限制**

   * 最大值限制（如生命值不超过100）

   * 最小值限制（如金币不能为负数）

   * 百分比自动限制在0-100%

4. **自定义属性系统**

   * 允许游戏作者定义任意数值属性

   * 示例：金币、生命值、魔法值、体力值、魅力值、好感度等

### 数据结构扩展

```typescript
interface GameState {
  // 现有状态
  暴露度: number;
  羞耻感: number;
  兴奋度: number;
  任务完成数: number;
  场景解锁数: number;
  
  // 新增自定义属性
  金币?: number;
  生命值?: number;
  魔法值?: number;
  体力值?: number;
  魅力值?: number;
  好感度?: number;
  // ...其他自定义属性
}

interface Choice {
  id: string;
  choice: string;
  effect: string;
  status_update: string;  // 保持兼容性，用于显示
  status_changes?: StatusChange[];  // 新增：数值变更
  next_branch: string;
}

interface StatusChange {
  attribute: string;  // 属性名（如"金币"、"暴露度"）
  operation: '+' | '-' | '*' | '/' | '=';  // 运算符
  value: number;  // 数值
  min?: number;  // 最小值限制
  max?: number;  // 最大值限制
}
```

### 实现逻辑

```typescript
// 解析 status_changes 并更新状态
const applyStatusChanges = (currentState: GameState, changes: StatusChange[]) => {
  const newState = { ...currentState };
  
  changes.forEach(change => {
    const currentValue = newState[change.attribute] || 0;
    let newValue: number;
    
    switch (change.operation) {
      case '+':
        newValue = currentValue + change.value;
        break;
      case '-':
        newValue = currentValue - change.value;
        break;
      case '*':
        newValue = currentValue * change.value;
        break;
      case '/':
        newValue = currentValue / change.value;
        break;
      case '=':
        newValue = change.value;
        break;
    }
    
    // 应用数值限制
    if (change.min !== undefined) {
      newValue = Math.max(newValue, change.min);
    }
    if (change.max !== undefined) {
      newValue = Math.min(newValue, change.max);
    }
    
    // 百分比自动限制
    if (change.attribute.includes('度') || change.attribute.includes('率')) {
      newValue = Math.max(0, Math.min(100, newValue));
    }
    
    newState[change.attribute] = newValue;
  });
  
  return newState;
};
```

***

## 三、状态管理系统（简化版）

### 问题分析

* 当前没有游戏进度保存功能

* 游戏库只有"开始游戏"按钮，缺少"继续游戏"和"新游戏"选项

* 游戏界面快捷操作区有"保存"按钮，但未实现功能

### 解决方案

1. **游戏进度数据结构**

```typescript
interface GameProgress {
  gameId: string;  // 游戏ID
  currentSceneId: string;  // 当前场景ID
  gameState: GameState;  // 游戏状态
  timestamp: string;  // 保存时间
  playTime: number;  // 游玩时长（秒）
}
```

2. **简化存档机制**

   * 每个游戏只保存一个最新进度（自动覆盖）

   * 点击"继续游戏"直接加载最新进度

   * 点击"新游戏"清除进度重新开始

3. **游戏内保存**

   * 游戏界面快捷操作区已有"保存"按钮

   * 修改该按钮的实现，保存当前场景、状态、历史记录

   * 自动覆盖之前的存档

4. **不实现游戏内读取**

   * 不在游戏界面添加"读取进度"按钮

   * 玩家需要读取进度时，返回游戏库点击"继续游戏"

### 数据库扩展

```typescript
// 在 GameDatabase 中添加新表
export class GameDatabase extends Dexie {
  games_index!: Table<GameIndexItem>;
  games_data!: Table<GameDataItem>;
  assets!: Table<AssetItem>;
  game_progress!: Table<GameProgress>;  // 新增：游戏进度表

  constructor() {
    super('GameDatabase');
    this.version(2).stores({
      games_index: 'id, title, priority, createdAt, updatedAt, version',
      games_data: 'id, createdAt, updatedAt',
      assets: 'id, type, name, createdAt',
      game_progress: 'gameId, timestamp'  // 新增
    });
  }
}
```

### GameStore 扩展

```typescript
export class GameStore {
  // 保存游戏进度（自动覆盖）
  async saveProgress(gameId: string, progress: Omit<GameProgress, 'gameId'>): Promise<void> {
    const fullProgress: GameProgress = {
      ...progress,
      gameId,
      timestamp: new Date().toISOString()
    };
    
    // 检查是否已有进度
    const existing = await db.game_progress.where('gameId').equals(gameId).first();
    
    if (existing) {
      // 更新现有进度
      await db.game_progress.put(fullProgress, existing.progressId || gameId);
    } else {
      // 创建新进度
      await db.game_progress.add(fullProgress);
    }
  }
  
  // 获取游戏进度
  async getGameProgress(gameId: string): Promise<GameProgress | null> {
    return await db.game_progress.where('gameId').equals(gameId).first();
  }
  
  // 删除游戏进度（新游戏时调用）
  async deleteGameProgress(gameId: string): Promise<void> {
    const progress = await db.game_progress.where('gameId').equals(gameId).first();
    if (progress) {
      await db.game_progress.delete(progress.progressId || gameId);
    }
  }
}
```

### UI 改动

#### 游戏库页面（game-library/page.tsx）

```tsx
// 为每个游戏卡片添加两个按钮
<Card>
  <CardContent>
    {hasProgress ? (
      <>
        <Button onClick={handleContinueGame}>
          <Play className="h-4 w-4 mr-2" />
          继续游戏
        </Button>
        <Button onClick={handleNewGame} variant="outline">
          <RefreshCw className="h-4 w-4 mr-2" />
          新游戏
        </Button>
      </>
    ) : (
      <Button onClick={handleNewGame}>
        <Play className="h-4 w-4 mr-2" />
        开始游戏
      </Button>
    )}
  </CardContent>
</Card>

// 检查是否有存档
const hasProgress = await gameStore.getGameProgress(game.id).then(p => p !== null);

// 继续游戏
const handleContinueGame = async (game: GameIndexItem) => {
  const progress = await gameStore.getGameProgress(game.id);
  if (progress) {
    const gameData = await gameStore.getGame(game.id);
    if (gameData) {
      // 保存进度数据到 sessionStorage
      sessionStorage.setItem('gameProgress', JSON.stringify(progress));
      sessionStorage.setItem('gameData', JSON.stringify(gameData.data.data));
      window.location.href = '/';
    }
  }
};

// 新游戏
const handleNewGame = async (game: GameIndexItem) => {
  const gameData = await gameStore.getGame(game.id);
  if (gameData) {
    // 删除旧进度
    await gameStore.deleteGameProgress(game.id);
    
    // 清除进度数据
    sessionStorage.removeItem('gameProgress');
    sessionStorage.setItem('gameData', JSON.stringify(gameData.data.data));
    window.location.href = '/';
  }
};
```

#### 游戏页面（page.tsx）- 修改现有保存按钮

```tsx
// 快捷操作区的保存按钮（修改实现）
<div className="quick-actions">
  <Button onClick={handleSaveProgress}>
    <Save className="h-4 w-4 mr-2" />
    保存进度
  </Button>
  {/* 其他快捷按钮... */}
</div>

// 保存进度实现
const handleSaveProgress = async () => {
  const gameData = JSON.parse(sessionStorage.getItem('gameData') || '{}');
  const gameId = gameData.game_title || 'unknown';
  
  const progress = {
    currentSceneId: currentScene?.id || '',
    gameState: gameState,  // 当前的游戏状态
    playTime: Math.floor((Date.now() - gameStartTime) / 1000)
  };
  
  await gameStore.saveProgress(gameId, progress);
  toast.success('进度已保存！');
};
```

***

## 实施步骤

### 第一阶段：数值累加系统

1. 扩展 GameState 接口，支持自定义属性
2. 创建 StatusChange 接口和解析逻辑
3. 实现 applyStatusChanges 函数
4. 在选择处理中应用数值变更
5. 在UI中显示实时状态

### 第二阶段：状态管理系统

1. 扩展 GameDatabase，添加 game_progress 表
2. 在 GameStore 中添加进度管理方法
3. 在游戏库页面添加"继续游戏"和"新游戏"按钮
4. 修改游戏页面快捷操作区的"保存"按钮实现
5. 实现存档逻辑（自动覆盖）

### 第三阶段：场景架构优化

1. 扩展 Scene 接口，添加 steps 和 conditions
2. 实现场景内分支逻辑
3. 实现步骤系统
4. 支持循环场景
5. 更新游戏编辑器支持新结构

***

## 兼容性保证

1. **向后兼容**

   * 保留现有的 `status_update` 字段用于显示

   * 新增 `status_changes` 字段用于数值更新

   * 如果没有 `status_changes`，只显示 `status_update`

2. **渐进式升级**

   * 旧游戏可以继续使用

   * 新游戏可以使用新功能

   * 游戏编辑器支持两种格式

3. **数据迁移**

   * 数据库版本升级时自动迁移数据

   * 保留旧数据，添加新表结构

***

## 测试计划

1. **数值累加测试**

   * 测试加减乘除运算

   * 测试数值限制

   * 测试自定义属性

2. **存档读档测试**

   * 测试保存进度（快捷操作区）

   * 测试继续游戏（游戏库）

   * 测试新游戏（游戏库）

3. **兼容性测试**

   * 测试旧游戏格式

   * 测试新游戏格式

   * 测试混合格式

***

这份方案已按照您的要求调整：
1. 不实现游戏内读取功能
2. 只修改游戏界面快捷操作区的保存按钮实现
3. 保留游戏库的继续游戏和新游戏功能

请确认是否可以开始实施？