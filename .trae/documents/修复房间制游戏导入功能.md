# 游戏编辑器导图修复计划

## 问题分析

通过分析代码，我发现了导图加载和拖动的以下问题：

### 1. 性能问题
- 当前代码在 `useEffect` 中一次性处理所有分支节点位置计算
- 对于大型游戏（如月王故事有16个分支），这会导致性能瓶颈
- SVG渲染所有节点和连接线，没有虚拟化或懒加载

### 2. 拖动功能问题
- `handleMouseDown` 只在 `e.target === graphRef.current` 时启用拖动
- 这意味着只有在点击空白区域时才能拖动，点击节点时无法拖动
- 拖动事件处理可能与其他鼠标事件冲突

### 3. 加载策略问题
- 所有节点一次性渲染，没有分页或分批处理
- 没有考虑视口边界，渲染了不可见的节点

## 修复方案

### 1. 实现懒加载机制
- 添加视口检测，只渲染可见区域内的节点
- 实现分批渲染，避免一次性处理所有节点
- 添加加载状态指示器

### 2. 修复拖动功能
- 修改拖动逻辑，允许在任何位置开始拖动
- 添加拖动阈值，避免误触
- 优化事件处理，避免冲突

### 3. 性能优化
- 使用 `requestAnimationFrame` 优化动画性能
- 添加防抖机制，减少不必要的重渲染
- 实现节点位置缓存，避免重复计算

### 4. 用户体验改进
- 添加加载进度指示
- 实现平滑的缩放和拖动动画
- 添加边界检测，防止拖出可视区域

## 具体修改内容

### 1. 修改拖动逻辑
```typescript
const handleMouseDown = (e: React.MouseEvent) => {
  // 移除对 graphRef.current 的限制，允许在任何位置开始拖动
  setIsDragging(true)
  setDragStart({ x: e.clientX - pan.x, y: e.clientY - pan.y })
}
```

### 2. 添加视口检测
```typescript
const getVisibleNodes = () => {
  const container = graphRef.current
  if (!container) return nodePositions
  
  const rect = container.getBoundingClientRect()
  const visibleArea = {
    x: -pan.x / scale,
    y: -pan.y / scale,
    width: rect.width / scale,
    height: rect.height / scale
  }
  
  return nodePositions.filter(pos => 
    pos.x >= visibleArea.x - 200 &&
    pos.x <= visibleArea.x + visibleArea.width + 200 &&
    pos.y >= visibleArea.y - 100 &&
    pos.y <= visibleArea.y + visibleArea.height + 100
  )
}
```

### 3. 实现分批渲染
```typescript
const [visibleNodes, setVisibleNodes] = useState<NodePosition[]>([])

useEffect(() => {
  const updateVisibleNodes = () => {
    const visible = getVisibleNodes()
    setVisibleNodes(visible)
  }
  
  // 使用 requestAnimationFrame 优化性能
  requestAnimationFrame(updateVisibleNodes)
}, [nodePositions, pan, scale])
```

### 4. 添加性能优化
```typescript
// 使用防抖机制
const debouncedSetPan = useCallback(
  debounce((newPan: { x: number; y: number }) => {
    setPan(newPan)
  }, 16), // 约60fps
  []
)
```

## 预期效果

1. **性能提升**：只渲染可见节点，大幅提升大型游戏的导图性能
2. **流畅拖动**：修复拖动功能，支持在任何位置开始拖动
3. **平滑体验**：添加动画和防抖，提供流畅的用户体验
4. **渐进加载**：避免一次性加载所有内容，减少初始加载时间