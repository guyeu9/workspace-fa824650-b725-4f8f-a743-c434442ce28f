# 游戏系统开发设计方案

## 1. 数值累加系统

### 1.1 GameState 接口

```typescript
export interface GameState {
  [key: string]: number;  // 支持任意自定义属性
}
```

**设计说明：**
- 使用索引签名 `[key: string]: number` 支持任意自定义属性
- 不再硬编码固定的状态属性
- 游戏可以自由定义任意数量的状态属性

### 1.2 StatusChange 接口

```typescript
export interface StatusChange {
  attribute: string;  // 属性名（如"金币"、"暴露度"）
  operation: '+' | '-' | '*' | '/' | '=';  // 运算符
  value: number;  // 数值
  min?: number;  // 最小值限制
  max?: number;  // 最大值限制
}
```

**设计说明：**
- 支持五种运算符：加、减、乘、除、赋值
- 支持数值限制：最小值、最大值
- 百分比属性自动限制在 0-100%

### 1.3 applyStatusChanges 函数

```typescript
applyStatusChanges(currentState: GameState, changes: StatusChange[]): GameState {
  const newState = { ...currentState };
  
  changes.forEach(change => {
    const currentValue = newState[change.attribute] || 0;
    let newValue: number;
    
    switch (change.operation) {
      case '+':
        newValue = currentValue + change.value;
        break;
      case '-':
        newValue = currentValue - change.value;
        break;
      case '*':
        newValue = currentValue * change.value;
        break;
      case '/':
        newValue = change.value !== 0 ? currentValue / change.value : currentValue;
        break;
      case '=':
        newValue = change.value;
        break;
      default:
        newValue = currentValue;
    }
    
    if (!isFinite(newValue)) {
      newValue = currentValue;
    }
    
    if (change.min !== undefined) {
      newValue = Math.max(newValue, change.min);
    }
    if (change.max !== undefined) {
      newValue = Math.min(newValue, change.max);
    }
    
    if (change.attribute.includes('度') || change.attribute.includes('率')) {
      newValue = Math.max(0, Math.min(100, newValue));
    }
    
    newState[change.attribute] = newValue;
  });
  
  return newState;
}
```

**设计说明：**
- 防止除零错误
- 检查无效数值（NaN、Infinity）
- 百分比自动限制在 min/max 之前应用，避免覆盖

### 1.4 游戏数据格式

```json
{
  "game_title": "游戏标题",
  "description": "游戏描述",
  "game_states": [
    {
      "name": "金币",
      "initial_value": 100,
      "min": 0,
      "max": 9999,
      "is_percentage": false
    },
    {
      "name": "暴露度",
      "initial_value": 0,
      "min": 0,
      "max": 100,
      "is_percentage": true
    }
  ],
  "branches": [
    {
      "branch_id": "scene_1",
      "branch_title": "场景标题",
      "content": "场景描述",
      "options": [
        {
          "option_id": "option_1",
          "option_text": "选项文本",
          "target_branch_id": "scene_2",
          "status_changes": [
            {
              "attribute": "金币",
              "operation": "+",
              "value": 10
            }
          ]
        }
      ]
    }
  ]
}
```

**设计说明：**
- 使用 `game_states` 字段定义游戏状态
- 在选项中使用 `status_changes` 字段应用数值变更
- 支持自定义状态属性

## 2. 状态管理系统（存档/读档）

### 2.1 GameProgress 接口

```typescript
export interface GameProgress {
  id: string;  // 主键
  gameId: string;  // 游戏ID
  currentSceneId: string;  // 当前场景ID
  gameState: GameState;  // 游戏状态
  timestamp: string;  // 保存时间
  playTime: number;  // 游玩时长（秒）
}
```

**设计说明：**
- 使用 `gameId` 作为主键，每个游戏只保存一个进度
- 保存完整的游戏状态和游玩时长

### 2.2 数据库设计

```typescript
this.version(2).stores({
  games_index: 'id, title, priority, createdAt, updatedAt, version',
  games_data: 'id, createdAt, updatedAt',
  assets: 'id, type, name, createdAt',
  game_progress: 'id, gameId, timestamp'
});
```

**设计说明：**
- 添加 `game_progress` 表存储游戏进度
- 使用 `gameId` 作为主键，每个游戏只保存一个进度
- 使用 `put` 方法自动处理更新和插入

### 2.3 GameStore 方法

```typescript
async saveProgress(gameId: string, progress: Omit<GameProgress, 'id' | 'gameId'>): Promise<void> {
  const fullProgress: GameProgress = {
    ...progress,
    id: gameId,
    gameId,
    timestamp: new Date().toISOString()
  };
  
  await db.game_progress.put(fullProgress);
}

async getGameProgress(gameId: string): Promise<GameProgress | null> {
  return await db.game_progress.where('gameId').equals(gameId).first();
}

async deleteGameProgress(gameId: string): Promise<void> {
  const progress = await db.game_progress.where('gameId').equals(gameId).first();
  if (progress) {
    await db.game_progress.delete(progress.id);
  }
}
```

**设计说明：**
- `saveProgress`：使用 `put` 方法自动处理更新和插入
- `getGameProgress`：使用索引查询进度
- `deleteGameProgress`：先查询再删除

### 2.4 游戏库页面

```typescript
const [gameProgresses, setGameProgresses] = useState<Record<string, boolean>>({})

const progressChecks = await Promise.all(filteredGames.map(async (game) => {
  const progress = await gameStore.getGameProgress(game.id);
  return { gameId: game.id, hasProgress: progress !== null };
}));

const progressMap: Record<string, boolean> = {};
progressChecks.forEach(({ gameId, hasProgress }) => {
  progressMap[gameId] = hasProgress;
});
setGameProgresses(progressMap);
```

**设计说明：**
- 使用 `Promise.all` 并行查询所有游戏的进度
- 使用 `Record<string, boolean>` 存储进度状态
- 根据进度状态显示不同的按钮

### 2.5 游戏页面

```typescript
const [gameState, setGameState] = useState<GameState>({})

const initialGameState: GameState = {}

if (data.game_states && Array.isArray(data.game_states)) {
  data.game_states.forEach((stateConfig: any) => {
    initialGameState[stateConfig.name] = stateConfig.initial_value
  })
}

setGameState(initialGameState)
setGameStatesConfig(data.game_states)
```

**设计说明：**
- 根据游戏数据中的 `game_states` 配置动态初始化游戏状态
- 保存状态配置以便后续使用
- 只显示游戏中定义的状态

## 3. 游戏编辑界面

### 3.1 GameStateConfig 接口

```typescript
interface GameStateConfig {
  name: string;
  initial_value: number;
  min?: number;
  max?: number;
  is_percentage?: boolean;
}
```

**设计说明：**
- 支持状态名称、初始值、最小值、最大值、百分比设置
- 可以添加、编辑、删除状态

### 3.2 状态配置功能

```typescript
const handleAddState = () => {
  const newStates = [...(gameData.game_states || [])]
  newStates.push({
    name: `状态_${newStates.length + 1}`,
    initial_value: 0,
    is_percentage: false
  })
  handleUpdateGame({ game_states: newStates })
}

const handleUpdateState = (index: number, updates: Partial<GameStateConfig>) => {
  const newStates = [...(gameData.game_states || [])]
  newStates[index] = { ...newStates[index], ...updates }
  handleUpdateGame({ game_states: newStates })
}

const handleDeleteState = (index: number) => {
  const newStates = [...(gameData.game_states || [])]
  newStates.splice(index, 1)
  handleUpdateGame({ game_states: newStates })
}
```

**设计说明：**
- 添加状态：自动生成状态名称
- 编辑状态：支持修改所有字段
- 删除状态：移除状态
- 使用索引更新状态

## 4. 游戏数据格式

### 4.1 字段映射

| 旧字段 | 新字段 | 说明 |
|---------|---------|------|
| `chapter` | `branch_title` | 场景标题 |
| `scene_detail` | `content` | 场景内容 |
| `choices` | `options` | 选项列表 |
| `choice` | `option_text` | 选项文本 |
| `next_branch` | `target_branch_id` | 目标分支ID |
| `effect` | `effect` | 效果 |
| `status_update` | `status_update` | 状态更新 |
| `status_changes` | `status_changes` | 状态变更 |

**设计说明：**
- 统一使用新字段名
- 支持向后兼容（可选字段）
- 在所有地方使用正确的字段名

## 5. UI 设计

### 5.1 状态显示

```typescript
<div className="flex flex-wrap justify-center gap-1.5 sm:gap-2.5 lg:gap-3 max-w-4xl mx-auto">
  {Object.entries(gameState).map(([key, value]) => (
    <div key={key} className="bg-white/80 backdrop-blur-sm border border-indigo-200 rounded-lg px-3 py-2 flex items-center gap-2 shadow-sm">
      <span className="text-xs sm:text-sm font-semibold text-indigo-600">{key}</span>
      <span className="text-sm sm:text-base font-bold text-slate-800">{value}</span>
    </div>
  ))}
</div>
```

**设计说明：**
- 使用 `Object.entries(gameState)` 动态显示所有状态
- 响应式布局，支持移动设备
- 状态卡片样式统一

### 5.2 按钮显示

```typescript
{gameProgresses[game.id] ? (
  <>
    <Button onClick={() => handleContinueGame(game)}>
      <Play className="h-3 w-3 mr-1" />
      继续游戏
    </Button>
    <Button onClick={() => handleNewGame(game)}>
      <RefreshCw className="h-3 w-3 mr-1" />
      新游戏
    </Button>
  </>
) : (
  <Button onClick={() => handleNewGame(game)}>
    <Play className="h-3 w-3 mr-1" />
    开始游戏
  </Button>
)}
```

**设计说明：**
- 有存档时显示"继续游戏"和"新游戏"按钮
- 无存档时显示"开始游戏"按钮
- 使用图标区分不同操作

## 6. 错误处理

### 6.1 数值变更错误处理

```typescript
if (!isFinite(newValue)) {
  newValue = currentValue;
}
```

**设计说明：**
- 防止除零错误
- 检查无效数值（NaN、Infinity）

### 6.2 存档/读档错误处理

```typescript
try {
  const gameData = JSON.parse(sessionStorage.getItem('gameData') || '{}');
  const gameId = gameData.game_title || 'unknown';
  
  const progress = {
    currentSceneId: currentScene?.id || '',
    gameState: gameState,
    playTime: Math.floor((Date.now() - gameStartTime) / 1000)
  };
  
  await gameStore.saveProgress(gameId, progress);
  toast.success('进度已保存！');
} catch (error) {
  console.error('保存进度失败:', error);
  toast.error('保存进度失败');
}
```

**设计说明：**
- 完善的 try-catch 错误处理
- 用户友好的错误提示
- 控制台日志记录

## 7. 数据流

### 7.1 游戏启动流程

```
用户点击游戏 → 
加载游戏数据 → 
初始化游戏状态（根据 game_states） → 
显示游戏界面
```

### 7.2 存档流程

```
用户点击保存 → 
保存当前状态和场景 → 
显示成功提示
```

### 7.3 读档流程

```
用户点击继续游戏 → 
加载游戏进度 → 
加载游戏数据 → 
恢复游戏状态和场景 → 
显示游戏界面
```

### 7.4 新游戏流程

```
用户点击新游戏 → 
删除游戏进度 → 
加载游戏数据 → 
初始化游戏状态（根据 game_states） → 
显示游戏界面
```

## 8. 测试建议

### 8.1 数值累加测试

1. 在游戏编辑器中添加自定义状态（如"金币"、"生命值"）
2. 开始游戏，验证状态是否正确显示
3. 选择不同的选项，观察状态数值的变化
4. 验证加减乘除运算
5. 验证数值限制和百分比限制
6. 测试边界情况：
   - 除零操作
   - 超出范围的数值
   - 无效数值

### 8.2 存档/读档测试

1. 开始一个游戏，玩到某个场景
2. 点击保存按钮
3. 返回游戏库，验证"继续游戏"按钮显示
4. 点击"继续游戏"，验证进度正确加载
5. 点击"新游戏"，验证进度清除
6. 测试错误情况：
   - 没有游戏数据时保存
   - 没有存档时继续游戏
   - 数据库错误时的处理

### 8.3 游戏编辑测试

1. 打开游戏编辑器
2. 点击"添加状态"按钮
3. 验证状态是否正确添加
4. 编辑状态名称、初始值、最小值、最大值
5. 设置是否为百分比
6. 删除状态
7. 保存游戏
8. 开始游戏，验证状态是否正确显示

## 9. 总结

### 9.1 核心功能

✅ 数值累加系统
- 支持任意自定义状态属性
- 支持五种运算符
- 支持数值限制
- 百分比自动限制
- 边界情况处理

✅ 状态管理系统
- 完整的存档/读档功能
- 每个游戏只保存一个进度
- 自动覆盖旧进度

✅ 游戏数据格式
- 统一使用新字段名
- 支持状态配置
- 支持向后兼容

✅ 游戏编辑界面
- 状态配置功能
- 添加、编辑、删除状态
- 支持初始值、最小值、最大值、百分比设置

✅ 游戏页面
- 根据游戏数据动态初始化状态
- 只显示游戏中定义的状态
- 实时状态显示
- 完善的错误处理

### 9.2 技术栈

- Next.js 15.3.5
- React 18
- TypeScript
- Dexie（IndexedDB）
- Tailwind CSS
- shadcn/ui

### 9.3 文件结构

```
src/
├── lib/
│   ├── game-store.ts          # 游戏存储管理
├── app/
│   ├── page.tsx              # 游戏主页面
│   ├── studio/page.tsx        # 游戏编辑器
│   └── game-library/page.tsx  # 游戏库页面
└── public/
    └── extreme-gay-adventure.json  # 测试游戏数据
```

## 10. 注意事项

1. **数据库版本管理**
   - 当前版本为 v2
   - 如果需要修改数据库结构，需要升级版本号

2. **状态配置持久化**
   - 游戏状态配置保存在游戏数据的 `game_states` 字段中
   - 游戏页面会读取并应用这些配置

3. **性能优化**
   - 使用 `Promise.all` 并行查询多个游戏的进度
   - 使用 `useCallback` 缓存函数，减少不必要的重渲染

4. **错误处理**
   - 所有数据库操作都有完善的错误处理
   - 所有用户操作都有友好的错误提示

5. **类型安全**
   - 使用 TypeScript 接口确保类型安全
   - 使用可选链 `?.` 和空值合并 `||` 防止空指针错误

6. **响应式设计**
   - 所有 UI 组件都支持响应式布局
   - 使用 Tailwind CSS 的响应式类名

7. **向后兼容**
   - 支持旧的游戏数据格式（`chapter`、`scene_detail`、`choices`）
   - 同时支持新的游戏数据格式（`branch_title`、`content`、`options`）

8. **测试建议**
   - 在开发环境中进行充分测试
   - 测试各种边界情况
   - 测试错误处理逻辑
   - 测试存档/读档功能

## 11. 更新日志

### 11.1 版本 1.0.0
- 初始实现数值累加系统和状态管理系统
- 修复游戏数据格式不匹配问题
- 修复数据库操作错误

### 11.2 版本 1.1.0（当前）
- 修复数值累加系统的边界情况（除零、无效数值）
- 修复游戏库页面的方法调用错误
- 添加游戏编辑界面的状态配置功能
- 修改 GameState 接口支持动态状态
- 修改游戏页面根据游戏数据动态初始化状态

### 11.3 版本 1.2.0（当前）
- 创建开发设计方案文档
- 完善所有功能的错误处理
- 优化代码结构和性能
- 添加完整的测试建议

### 11.4 版本 1.3.0
- 全面清理了项目中所有无用文件
- 删除了 src/__tests__ 和 tests 目录下的 9 个测试文件
- 删除了 13 个日志文件（*.log）
- 删除了 2 个临时 JSON 文件
- 更新了项目文档，记录了清理过程和结果

---

**文档创建时间：** 2026-01-15
**最后更新：** 清理项目无用文件，优化项目结构