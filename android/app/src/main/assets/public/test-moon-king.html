<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>测试月王故事文件加载</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .result {
            background: #f5f5f5;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }
        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .error {
            color: red;
        }
        .success {
            color: green;
        }
    </style>
</head>
<body>
    <h1>测试月王故事文件加载</h1>
    
    <div class="test-section">
        <h2>1. 测试文件读取</h2>
        <input type="file" id="fileInput" accept=".json">
        <button onclick="testFileLoad()">读取文件</button>
        <div id="fileResult" class="result"></div>
    </div>
    
    <div class="test-section">
        <h2>2. 测试数组处理</h2>
        <button onclick="testArrayProcessing()">测试数组处理函数</button>
        <div id="arrayResult" class="result"></div>
    </div>
    
    <div class="test-section">
        <h2>3. 测试println函数</h2>
        <button onclick="testPrintln()">测试println重写</button>
        <div id="printlnResult" class="result"></div>
    </div>

    <script>
        // 复制修复后的函数进行测试
        function processGameData(gameData) {
            try {
                console.log('Processing game data...');
                console.log('Game data:', gameData);
                
                // Normalize the game data to ensure consistent field names
                // Support both roomId and playerId for player start position
                if (gameData.roomId && !gameData.playerId) {
                    gameData.playerId = gameData.roomId;
                    console.log('Converted roomId to playerId for compatibility:', gameData.playerId);
                }
                
                // Process game data to convert array descriptions to strings
                const processedGameData = { ...gameData };
                
                // Process rooms array
                if (processedGameData.rooms) {
                    processedGameData.rooms = processedGameData.rooms.map(room => {
                        const processedRoom = { ...room };
                        
                        // Convert desc array to string if it's an array
                        if (Array.isArray(processedRoom.desc)) {
                            processedRoom.desc = processedRoom.desc.join('\n\n');
                        }
                        
                        // Convert item descriptions in the room
                        if (processedRoom.items) {
                            processedRoom.items = processedRoom.items.map(item => {
                                const processedItem = { ...item };
                                if (Array.isArray(processedItem.desc)) {
                                    processedItem.desc = processedItem.desc.join('\n\n');
                                }
                                // Convert onTake, onUse arrays to strings as well
                                if (Array.isArray(processedItem.onTake)) {
                                    processedItem.onTake = processedItem.onTake.join('\n\n');
                                }
                                if (Array.isArray(processedItem.onUse)) {
                                    processedItem.onUse = processedItem.onUse.join('\n\n');
                                }
                                return processedItem;
                            });
                        }
                        
                        // Convert character descriptions in the room
                        if (processedRoom.characters) {
                            processedRoom.characters = processedRoom.characters.map(character => {
                                const processedCharacter = { ...character };
                                if (Array.isArray(processedCharacter.desc)) {
                                    processedCharacter.desc = processedCharacter.desc.join('\n\n');
                                }
                                // Convert topic lines to strings
                                if (processedCharacter.topics) {
                                    const processedTopics = {};
                                    Object.keys(processedCharacter.topics).forEach(topicKey => {
                                        const topic = processedCharacter.topics[topicKey];
                                        processedTopics[topicKey] = {
                                            ...topic,
                                            line: Array.isArray(topic.line) ? topic.line.join('\n\n') : topic.line
                                        };
                                    });
                                    processedCharacter.topics = processedTopics;
                                }
                                return processedCharacter;
                            });
                        }
                        
                        // Convert onEnter and onChoose arrays to strings
                        if (Array.isArray(processedRoom.onEnter)) {
                            processedRoom.onEnter = processedRoom.onEnter.join('\n\n');
                        }
                        if (processedRoom.exits) {
                            processedRoom.exits = processedRoom.exits.map(exit => {
                                const processedExit = { ...exit };
                                if (Array.isArray(processedExit.onChoose)) {
                                    processedExit.onChoose = processedExit.onChoose.join('\n\n');
                                }
                                return processedExit;
                            });
                        }
                        
                        return processedRoom;
                    });
                }
                
                // Process global characters array
                if (processedGameData.characters) {
                    processedGameData.characters = processedGameData.characters.map(character => {
                        const processedCharacter = { ...character };
                        if (Array.isArray(processedCharacter.desc)) {
                            processedCharacter.desc = processedCharacter.desc.join('\n\n');
                        }
                        // Convert topic lines to strings
                        if (processedCharacter.topics) {
                            const processedTopics = {};
                            Object.keys(processedCharacter.topics).forEach(topicKey => {
                                const topic = processedCharacter.topics[topicKey];
                                processedTopics[topicKey] = {
                                    ...topic,
                                    line: Array.isArray(topic.line) ? topic.line.join('\n\n') : topic.line
                                };
                            });
                            processedCharacter.topics = processedTopics;
                        }
                        return processedCharacter;
                    });
                }
                
                return processedGameData;
            } catch (error) {
                console.error('Error processing game data:', error);
                throw error;
            }
        }

        function testFileLoad() {
            const fileInput = document.getElementById('fileInput');
            const result = document.getElementById('fileResult');
            
            if (!fileInput.files[0]) {
                result.innerHTML = '<span class="error">请选择一个文件</span>';
                return;
            }
            
            const file = fileInput.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const gameData = JSON.parse(e.target.result);
                    result.innerHTML = '<span class="success">文件解析成功！</span>';
                    
                    // 测试数据处理
                    const processedData = processGameData(gameData);
                    
                    // 显示处理结果
                    const startRoom = processedData.rooms.find(room => room.id === processedData.playerId);
                    if (startRoom) {
                        result.innerHTML += '<h3>起始房间信息：</h3>';
                        result.innerHTML += '<p><strong>名称：</strong>' + startRoom.name + '</p>';
                        result.innerHTML += '<p><strong>描述：</strong><pre>' + startRoom.desc + '</pre></p>';
                        
                        if (startRoom.characters) {
                            result.innerHTML += '<h3>角色信息：</h3>';
                            startRoom.characters.forEach(char => {
                                result.innerHTML += '<p><strong>角色：</strong>' + (Array.isArray(char.name) ? char.name.join(', ') : char.name) + '</p>';
                                if (char.topics) {
                                    Object.keys(char.topics).forEach(topicKey => {
                                        const topic = char.topics[topicKey];
                                        result.innerHTML += '<p><strong>话题 ' + topicKey + '：</strong>' + topic.option + '</p>';
                                        result.innerHTML += '<p><strong>对话：</strong><pre>' + topic.line + '</pre></p>';
                                    });
                                }
                            });
                        }
                    }
                    
                } catch (error) {
                    result.innerHTML = '<span class="error">文件解析失败：' + error.message + '</span>';
                }
            };
            
            reader.readAsText(file);
        }

        function testArrayProcessing() {
            const testData = {
                rooms: [{
                    id: 'test',
                    name: '测试房间',
                    desc: ['第一行描述', '第二行描述', '第三行描述'],
                    characters: [{
                        name: ['万律', '真辉'],
                        desc: '你的战友，眼神暧昧，话语中带着诱惑。',
                        topics: {
                            '接受': {
                                option: '接受卧底任务',
                                line: ['月王最终被说服，内心隐隐兴奋，鸡巴微微硬起。获得卧底身份3397号。']
                            }
                        }
                    }]
                }],
                playerId: 'test'
            };
            
            const result = document.getElementById('arrayResult');
            
            try {
                const processedData = processGameData(testData);
                
                result.innerHTML = '<span class="success">数组处理测试成功！</span>';
                result.innerHTML += '<h3>原始数据：</h3>';
                result.innerHTML += '<p>desc数组：' + JSON.stringify(testData.rooms[0].desc) + '</p>';
                result.innerHTML += '<p>line数组：' + JSON.stringify(testData.rooms[0].characters[0].topics.接受.line) + '</p>';
                
                result.innerHTML += '<h3>处理后数据：</h3>';
                result.innerHTML += '<p>desc字符串：<pre>' + processedData.rooms[0].desc + '</pre></p>';
                result.innerHTML += '<p>line字符串：<pre>' + processedData.rooms[0].characters[0].topics.接受.line + '</pre></p>';
                
            } catch (error) {
                result.innerHTML = '<span class="error">数组处理测试失败：' + error.message + '</span>';
            }
        }

        function testPrintln() {
            const result = document.getElementById('printlnResult');
            
            // 模拟原始println函数
            const originalPrintln = function(line, className) {
                result.innerHTML += '<p>原始println输出：<span class="' + (className || '') + '">' + line + '</span></p>';
            };
            
            // 重写println函数
            window.println = function(line, className) {
                let processedLine = line;
                if (Array.isArray(line)) {
                    processedLine = line.join('\n\n');
                }
                return originalPrintln(processedLine, className);
            };
            
            // 测试不同类型的输入
            result.innerHTML = '<h3>测试println函数：</h3>';
            
            // 测试字符串
            println('这是一个字符串测试');
            
            // 测试数组
            println(['这是数组第一行', '这是数组第二行', '这是数组第三行']);
            
            // 测试月王故事的line数组
            const moonKingLine = ['月王最终被说服，内心隐隐兴奋，鸡巴微微硬起。获得卧底身份3397号。'];
            println(moonKingLine);
            
            result.innerHTML += '<span class="success">println重写测试完成！</span>';
        }
    </script>
</body>
</html>